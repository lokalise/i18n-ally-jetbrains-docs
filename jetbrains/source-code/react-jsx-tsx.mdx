---
sidebar_label: 'React (JSX/TSX)'
sidebar_position: 1
title: ""
---


import SupportedFeatures from './_partials/_features_supported.md';
import Scope from './_partials/_scope.mdx';
import ReplacementTemplate from './_partials/_replacement_template.mdx';
import SupportedConstructs from './_partials/_supported_constructs.mdx';
import TranslatableAttribute from './_partials/_translatable_attribute.md';

# React (JSX/TSX)
**Important!** Always configure both React and plain JavaScript sources together.

```jsx
<p>Hello world!</p>
⬇
<p>{t('helloWorld')}</p>
<!-- locales/en.js: helloWorld: 'Hello world!' -->

<p>Hello, {user}!</p>
⬇
<p>{t('hello', {user: user})}</p>
<!-- locales/en.js: helloWorld: 'Hello, {{user}}!' -->
```

## Features supported
<SupportedFeatures/>

## Configure hardcoded strings extraction from React (JSX/TSX) templates
The plugin should automatically configure itself for project with dependencies on `react-i18next`, but adjustments could be needed for custom setup.

![img.png](assets/jsx.png)

### Scope
<Scope fileName=".js/.jsx/.tsx"/>

### Inline tags
Extraction of strings with a special treatment of inline tags is not currently supported.

### Translatable attribute names
<TranslatableAttribute/>

### Replacement template
The “Replacement template” reflects the result of the hardcoded string extraction.function name and arguments template.

Recommended value for `react-i18next` packages: `t('%namespace%:%key%', %map%)`.

<ReplacementTemplate mapTemplate="t('namespace:key', {foo: fooVariable, bar: barVariable})"
                     listTemplate="t('namespace:key', [fooVariable, barVariable])"
                     argsTemplate="t('namespace.key', fooVariable, barVariable)"/>

## Supported language constructs
<SupportedConstructs/>

## What strings are skipped
 - All attributes except ones listed in “Translatable attribute names” preference.
 - Strings that looks like code: without letters, multiple words without spaces or `camelCased` ones.

## Best practice: dealing with branching in messages
It’s common to have small and simple branching for presentation purposes:
```jsx
return <>Webhook {isSuccess ? 'succeeded' : 'failed'}.</>;
```
The best practice it to separate this message into two different ones so translators would have a full context and would be able to adjust word order according the target language grammar.

**1st step**: manually extract the condition out of the message to get two messages without condition
```jsx
return isSuccess
  ? return <>Webhook succeeded.</>
  : return <>Webhook failed.</>;
```

**2nd step**: replace simple messages with i18n Ally
```jsx
return isSuccess
    ? return <>{t('webhookSucceeded')}</>
    : return <>{t('webhookFailed')}</>;
```